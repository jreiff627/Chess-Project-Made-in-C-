#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>
#include <ncurses.h>
#include <ctype.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>
#include "PieceMovementW.h"
#include "PieceMovementB.h"
#include "PrintingBoard.h"
#include "CheckMate.h"
//#include "ComputerEngine.h"
//#include "CapturingEnemy.h"


// ### Begining of our Chess Program Draft ###
/*
Start with a board. Learn how to get that board on the screen. 
After that, implement an overlay with the pieces. 
Implement moving pieces without rules (keyboard input) 
Implement the basic chess rules.
Implement castling, en passant and promoting.
Implement Check, and Checkmate.
Implement Timer and menu at beginning for user to select what style of game they want
-----
Have a computer make decisions for a one player game.
  - have a basic/generic opening that starts autogenerated based of which pawns are started.
  - take up optimial locations first (control over center, develop main pieces)
  - have a risk assumption on taking pieces, i.e which piece is worth more but also play more conservative for higher value pieces.
  - go for easy pieces to take
  - always try to protect the king
*/


//Define Board Size and also able to clear the screen with different Operating systems
#define BOARD_SIZE 8
#ifdef _WIN32
#define CLEAR_SCREEN "cls"
#else
#define CLEAR_SCREEN "clear"
#endif
/*
void Timer(int value){

  int seconds = value;
  int minutes = value / 60;

  while(seconds > 0){
   printf("\r%02d:%02d", minutes, seconds);
  fflush(stdout);
    clock_t stop = clock() + CLOCKS_PER_SEC;
    while(clock90 < stop){}
    seconds--;
  }
  printf("\r Times's up!\n")
}
*/

//////////// Win-Lose Scenarions //////////////////
char forfeit(char* quit){ // If the User enters q the game will end. 
    char ask;
  if (strchr(quit, 'q') != NULL){
    printf("\nDo you want to exit the game? (y/n)");
    scanf(" %c", &ask);
    if (ask == 'y' || ask == 'Y'){
        printf("Thank you for playing Chess!\n");
        exit(0);
      }
    else if (ask == 'n' || ask == 'N'){
      printf("Game will resume\n");
    }
    else {printf("Invalid Input. Game is Resuming\n");{
    return 0;
  }
 }
}
}

void currTurn (const char *message)
{
printf(message);
printf(" Enter in a move(ex, E2 E4): ");
}


void initializeBoard(char board[BOARD_SIZE][BOARD_SIZE]);

// print labels and pieces onto the board
void printBoard(char board[BOARD_SIZE][BOARD_SIZE]);

void classvalue(char board[BOARD_SIZE][BOARD_SIZE]);

void initializedBoard(char board[BOARD_SIZE][BOARD_SIZE]){
  //Set up the empty slots
  for(int i = 2; i < BOARD_SIZE -2; i++){
    for(int j = 0; j < BOARD_SIZE; j++){
      board[i][j] = ' ';
    }
  }

//Set up the pawns for Black and White
  for(int i = 0; i < BOARD_SIZE; i++){
  board[1][i] = 'P'; //White pieces on the second row
  board[6][i] = 'p'; //Black pieces on the seventh row
}
//Set up the beginning game pieces on the first and 8th rows
  char pieces[]= "RNBQKBNR"; // set up the row as a string type to be analyzed within the forloop
    for( int i = 0; i < BOARD_SIZE; i++){
      board[0][i] = pieces[i]; // first row for white
      board[7][i] = pieces[i] + 32; // eigth row for black, converting to lowercase for UniCode Transformation later

    }

}


//Main menu/intro
 int main(void) {

  int menuChoice;
  int timerChoice;
  int valueTimer;
  char cont;
   
while(1){
  printf("----------------------------\n");
  printf("EE285 Project: Chess Program\n");
  printf("----------------------------\n");
  printf("1. Play chess against person.\n");
  printf("2. Play chess against AI.\n");
  printf("3. Rules and piece movements.\n");
  printf("4. Special movements. \n");
  printf("5. Helpful tips for beginners.\n");
  printf("6. Quit program.\n\n");

  printf("Enter number of choice: ");
    scanf("%d", &menuChoice);

  switch(menuChoice){

    case 1:

      printf("\nChoose timer length\n");
      printf("-------------------\n");
      printf("1. 3 minutes\n");
      printf("2. 10 minutes\n");
      printf("3. 25 minutes\n\n");

      printf("Enter number of choice: ");
        scanf("%d", &timerChoice);

      switch(timerChoice){

        case 1:
          printf("\nYou have chosen 3 minutes.\n");
            //valueTimer = 180;
            break;

        case 2:
          printf("\nYou have chosen 10 minutes.\n");
           // valueTimer = 600;
            break;

        case 3:
          printf("\nYou have chosen 25 minutes.\n");
          //valueTimer = 1500;
          break;

        default:
          printf("\nInvalid input, please try again.\n");
          break;
      }


        int badMove = 0;
        int check = 0;
        int possibility;
        int checkmate = 0;
        char board[BOARD_SIZE][BOARD_SIZE];
        int BlockEnemy; // variable used to detect if the king is in check, if friendly piece can take on piece that has put the enemy slot in check.

      //Variables for Character Movement
        int orgRow ,orgCol, destRow, destCol; // numeric values for row and column
        char orgColChar, destColChar; //user input of orginal and destination

      initializedBoard(board);
      printBoard(board);

      while (1){
      //printf("{White's Turn} Enter in a move(ex,E2 E4): ");
        if(countW == countB){
          char message[] = "{White's Turn}"; currTurn(message);
          check = checkKingSafetyW(board);
          if(check != 0){ //If the king is in Check
          char message[] = "Your King is in Check.";popup(message);
          //run CheckMate scenarios
          checkmate = 0;
          int One = CanKingMoveW(board);
          if(One == 0){
          char message[] = "Your king can move out of harms way.";
          popup(message);}
          else{
            char message[] = "Your king can not move out of harms way.";
            popup(message);
            checkmate += 1;
          }
            //If the Piece can be taken out
            int ip = GetRowEnemy();
            int jp = GetColEnemy();
            possibility = checkPieceSafetyB(board, ip, jp);
            //if possibility is not 0, the piece can be taken
            if(possibility == 0){
              checkmate += 1; 
              char message[] = "The Offending Piece cannot be captured\t";
              popup(message);
            }
            //Can a piece block the path
            int trying = 0;
            int ik = findKingWRow(board);
            int jk = findKingWCol(board);
            if(checkmate == 2){
              switch(check){
                case 1: //pawn
                //Pawn is only one space away, nothing can move between it
                checkmate += 1;
                break;
                case 2: //knight
                //Knight jumps pieces, nothing can move between it
                checkmate += 1;
                break;
                case 3: //Rook
                trying = RookBlockW(board, ip, jp, ik, jk);
                if(trying == 0){checkmate +=1;}
                break;
                case 4: //Bishop
                trying = BishopBlockW(board, ip, jp, ik, jk);
                if(trying == 0){checkmate +=1;}
                break;
                case 5: //Queen
                trying = RookBlockW(board, ip, jp, ik, jk);
                trying += BishopBlockW(board, ip, jp, ik, jk);
                if(trying == 0){checkmate +=1;}
                break;
                case 6: //King
                break;
              }
            }
          }
          if(checkmate == 3){
            char message[] = "You have no possible moves. Checkmate! Black Wins!";
            popup(message);
            exit(0);
          }
        }
        else{
        char message[] = "{Black's Turn}"; 
        currTurn(message);
        check = checkKingSafetyB(board);
        if(check != 0){
        possibility = 0;
        char message[] = "Your King is in Check.\t\t\t";popup(message);
          //Checking if the King can Move out of Harm's way
          int Move = CanKingMoveB(board);
          if(Move > 0){
          char message[] = "Your king can move out of harms way.";popup(message);possibility = 1;}
          else{char message[] = "Your king can not move out of harms way.";popup(message);}
          //If the Piece can be taken out
          int ip = GetRowEnemy();
          int jp = GetColEnemy();
          possibility = checkPieceSafetyW(board, ip, jp);
          //if possibility is not 0, the piece can be taken
          if(possibility == 0){
            checkmate += 1; 
            char message[] = "The Offending Piece cannot be captured\t";
            popup(message);
          }
          //Can a piece block the path
          int trying = 0;
          int ik = findKingBRow(board);
          int jk = findKingBCol(board);
          if(checkmate == 2){
            switch(check){
              case 1: //pawn
              //Pawn is only one space away, nothing can move between it
              checkmate += 1;
              break;
              case 2: //knight
              //Knight jumps pieces, nothing can move between it
              checkmate += 1;
              break;
              case 3: //Rook
              trying = RookBlockB(board, ip, jp, ik, jk);
              if(trying == 0){checkmate +=1;}
              break;
              case 4: //Bishop
              trying = BishopBlockB(board, ip, jp, ik, jk);
              if(trying == 0){checkmate +=1;}
              break;
              case 5: //Queen
              trying = RookBlockB(board, ip, jp, ik, jk);
              trying += BishopBlockB(board, ip, jp, ik, jk);
              if(trying == 0){checkmate +=1;}
              printf("Piece Block: %d", trying);
              break;
              case 6: //King
              break;
            }
          }
          if(checkmate == 3){
          char message[] = "You have no possible moves. Checkmate! White Wins!";
          popup(message);
          exit(0);
          }
        }
        }
      scanf(" %c%d %c%d", &orgColChar,&orgRow,&destColChar,&destRow);
      if (orgColChar == 'q'){
      forfeit(&orgColChar); // Checking the escape sequence is not being activated
      }

      //Mapping the user input to the board
        orgColChar = toupper(orgColChar); // Ensuring User Input is an uppercase
        destColChar = toupper(destColChar);
        if (orgColChar < 'A' || orgColChar > 'H'){  //Checking the Columns are Valid
          printf("Invalid Input. Please try again, enter a letter between A and H\n");
          char message[] = "Invalid Input. Please try again, enter a letter between A and H\n"; popup(message);
          badMove = 1;
        }
        else if(destColChar < 'A' || destColChar > 'H'){ //Checking for valid columns
          printf("Invalid Input. Please try again, enter a letter between A and   H\n");
          char message[] = "Invalid Input. Please try again, enter a letter between A and   H\n";popup(message);
          badMove = 1;
        }
        else if (orgRow < 1 || orgRow > 8){
          printf("Invalid Input. Please try again, enter a number between 1 and 8\n");
          char message[] = "Invalid Input. Please try again, enter a number between 1 and 8\n";popup(message);
          badMove = 1;
        }
        else if (destRow < 1 || destRow > 8){
          printf("Invalid Input. Please try again, enter a number between 1 and 8\n");
          char message[] = "Invalid Input. Please try again, enter a number between 1 and 8\n";popup(message);
          badMove = 1;
        }
        else{
        orgCol = orgColChar - 'A';
        destCol = destColChar - 'A';
        orgRow = 8 - orgRow; //Converting the row into a index from 0-7
        destRow= 8 - destRow; // ^
        }
        if (countW == countB && isupper(board[orgRow][orgCol])){
          char message[] = "White Player must move it's own piece";popup(message);
        }
        else if (countW != countB && islower(board[orgRow][orgCol])){
            char message[] = "Black Player must move it's own piece";popup(message);
        }
      //Call the function to move the piece
      if(badMove == 0) { 
        // checking the move is valid, so it does not run invalid variables through the functions
        check = 0;
        if(countW == countB){ 
          //Checking again it is whites turn
          movePieceW(board,orgRow,orgCol,destRow,destCol);
          printf("Countw = %d\n", countW);
        }

        else{ //If it is not Whites turn it must be blacks turn
        // Before allowing a piece to move, check the security of the King

        movePieceB(board,orgRow,orgCol,destRow,destCol, check);
        printf("Countb = %d\n", countB);

      }
      }

      //Clear the screen :)
      system(CLEAR_SCREEN);

      // Reprint the Board, can I call the function again?
      printBoard(board);
      badMove = 0;
      }

      break;

    case 2:
      //note: add timer amount option with switch statement
      //(game against AI function)
    printf("This option is currently unavailable, please choose another.\n");
      break;

    case 3:
      printf("Rules and Piece movements\n");
      printf("-------------------------\n");

      printf("Pawn:\n ");
      printf(" - Can move 2 spaces straight forward on first move, 1 space forward on all other moves.\n");
      printf("- Can only capture a piece capture diagonally forward.\n");
      printf("- Can only move forward, cannot move backwards or to the side.\n");
      printf("- Can perform special en passant and promotion movements\n\n");

     printf("Rook:\n");
      printf("- Can move forward and sideways any number of spaces.\n");
      printf("- Can only capture a piece if it is in the same row or column.\n");
      printf("- Can not jump over any pieces.\n");
      printf("- Can perform special castling movement.\n\n");

      printf("Knight:\n");
      printf("- Can move in an L shape, 2 spaces forward and 1 space sideways, or vice versa.\n");
      printf("- Can jump over any piece black or white, to get to the desired square.\n\n");

      printf("Bishop:\n"
      "- Can move diagonally any number of spaces.\n"
      "- Can only capture a piece if it is in the same diagonal.\n"
      "- Can not jump over any pieces, occupies square of taken piece.\n"


      "Queen:\n"
      "- Can move in any direction forward sideways or diagonally.\n"
      "- Can only capture a piece if it is in the same row, column or diagonal.\n"
      "- Can not jump over any pieces, occupies spot of piece taken.\n\n"

      "King:\n"
      "- Can move 1 space in any direction it pleases./n"
      "- Can not be taken like any conventional piece, has to be put in checkmate.\n"
      "- Can perform special castling move\n\n");
      break;

    case 4:
        printf("Special Movements\n");
        printf("-----------------\n");

        printf("En Passant- A movement that allows you to take a pawn that is to the side of your own pawn by moving to the diagonal above it, as long as it follows these rules:\n"
       " 1. Your pawn must have advanced exactly three ranks to perform this move.\n"
       " 2. The enemy pawn must have moved two squares in one move, landing right next to the capturing pawn.\n"
       " 3. The en passant capture must be performed on the turn immediately after the enemy pawn moves. If you" "do not capture en passant on that turn, you no longer can do it.\n\n");

       printf(" Castling- A movement that allows you to move your king 2 spots to the side and then switch places with the rook and move the king to the other side of the rook as long as it follows these rules:\n"
       " 1. The king and rook have not yet moved in the game.\n"
       " 2. The king is not currently in check.\n"
       " 3. No square the king would castle through is under attack.\n"
       " 4. The squares between king and rook are unoccupied.\n\n");

       printf(" Promotion- A movement that allows you to turn a pawn into any piece of your choice, beides king, if it reaches the opponents back row.\n\n");
    break;

    case 5:
        printf("Helpful tips for beginners\n");
        printf("--------------------------\n");

        printf("1. Understand how openings moves work.\n"
       "2. Try to take control of the center board.\n"
       "3. Don’t bring your queen out too early as it risks being taken.\n"
       "4. Don't move the same piece multiple times in the opening.\n"
       "5. Try to keep your king safe and well defended.\n"
       "6. Look for tactical opportunities before making a plan.\n"
       "7. Remember that the king becomes a strong piece in the endgame.\n"
       "8. Remember that not all games need to end in checkmate – stalemate and draw are also possibilities.\n");
      
          break;
    
    case 6:
    exit(0);
    break;
    
   default:
   printf("Invalid choice. Please try again.\n");
   break;
  }
  printf("Click C to continue: ");
  while(1){
    scanf(" %c", &cont);
    if(cont != 'c' || cont !='C'){
      break;
    }
  }
  system(CLEAR_SCREEN);
 }

}





